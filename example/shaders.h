#pragma once

#define WITH_GEOMETRY_SHADER 0
#define TEXTURE_INDICES 1
#if WITH_GEOMETRY_SHADER
static const char* vs =
    "#version 330 core\n"
    "layout(location = 0) in vec3 a_Position; "
    "void main() { "
    "   gl_Position = vec4(a_Position, 1.0); "
    "}";

const char* gs =
    "#version 330 core\n"
    "uniform mat4 u_ModelMatrix; "
    "uniform mat4 u_ViewMatrix; "
    "uniform mat4 u_ProjectionMatrix; "
    "uniform vec2 u_ViewportSize = vec2(800,600);"
    "uniform samplerBuffer coordinates;"
    "uniform samplerBuffer triangles;"
    "layout (triangles) in;"
    ""
    "noperspective out vec3 v_Position;"
    "noperspective out vec3 altitude;"
    "out vec3 v_Normal;"
    "noperspective out vec2 v_Barycentric;"
    ""
    "layout (triangle_strip , max_vertices = 3) out;"
    ""
    "void main() {"
    "  vec4 u = vec4(gl_in[1].gl_Position.xyz - gl_in[0].gl_Position.xyz, 0.0);"
    "  vec4 v = vec4(gl_in[2].gl_Position.xyz - gl_in[0].gl_Position.xyz, 0.0);"
    "  vec3 n = normalize(mat3(transpose(inverse(u_ViewMatrix * "
    "u_ModelMatrix))) * "
    "cross(u.xyz, v.xyz));"
    "  mat4 mv = u_ViewMatrix * u_ModelMatrix;"
    "  mat4 mvp = u_ProjectionMatrix * mv;"
    "  vec4 p0 = mvp * gl_in[0].gl_Position;"
    "  vec4 p1 = mvp * gl_in[1].gl_Position;"
    "  vec4 p2 = mvp * gl_in[2].gl_Position;"
    ""
    "  vec2 q0 = p0.xy / p0.w;"
    "  vec2 q1 = p1.xy / p1.w;"
    "  vec2 q2 = p2.xy / p2.w;"
    ""
    "  vec2 v1 = u_ViewportSize * (q1 - q0);"
    "  vec2 v2 = u_ViewportSize * (q2 - q0);"
    "  vec2 v3 = u_ViewportSize * (q2 - q1);"
    ""
    "  float area = abs(v1.x * v2.y - v1.y * v2.x);"
    "  float h1 = area / length(v3);"
    "  float h2 = area / length(v2);"
    "  float h3 = area / length(v1);"
    ""
    "  gl_Position = p0;"
    "  v_Position  = (mv * gl_in[0].gl_Position).xyz;"
    "  altitude    = vec3(h1, 0, 0);"
    "  v_Normal = n;"
    "  v_Barycentric = vec2(0,0);"
    "  EmitVertex();"
    ""
    "  gl_Position = p1;"
    "  v_Position  = (mv * gl_in[1].gl_Position).xyz;"
    "  altitude    = vec3(0, h2, 0);"
    "  v_Normal = n;"
    "  v_Barycentric = vec2(1,0);"
    "  EmitVertex();"
    ""
    "  gl_Position = p2;"
    "  v_Position  = (mv * gl_in[2].gl_Position).xyz;"
    "  altitude    = vec3(0, 0, h3);"
    "  v_Normal = n;"
    "  v_Barycentric = vec2(0,1);"
    ""
    "  gl_PrimitiveID = gl_PrimitiveIDIn;"
    ""
    "  EmitVertex();"
    "  EndPrimitive();"
    "}";

const char* fs =
    "#version 330 core\n"
    "out vec4 fragColor;"
    "uniform int u_edges;"
    "uniform int u_lighting = 1;"
    ""
    "noperspective in vec3 altitude;"
    "in vec3 v_Normal;"
    "noperspective in vec2 v_Barycentric;"
    "noperspective in vec3 v_Position;"
    ""
    "void "
    "shading(in vec3 l , in vec3 n , in vec3 color , out vec3 color_out) {"
    "  float diffuse = max(0.0,abs(dot(l,n)));"
    "  float phong = 128.0;"
    "  float specular = pow(max(0.0, dot(-reflect(l, n), n)), phong);"
    ""
    "  vec3 cd = color * diffuse;"
    "  vec3 cs = vec3(0.1) * specular;"
    "  vec3 ca = vec3(0.2);"
    "  color_out = ca + cd + cs;"
    "}"

    "void main() {"
    "  float d = min(min(altitude[0], altitude[1]), altitude[2]);"
    "  float I = exp2(-0.5 * d * d);"
    ""
    "  vec3 position = normalize(v_Position);"
    "  vec3 normal = normalize(v_Normal);"
    ""
    "  vec3 color = vec3(0.8, 0.8, 0.8);"
    ""
    "  vec3 color_shaded;"
    "  shading(-position, normal, color, color_shaded);"
    ""
    "  vec3 color_out = color * (1 - u_lighting) + u_lighting * color_shaded;"
    ""
    " fragColor = I * vec4(0, 0, 0, 1.0) + (1.0 - I) * vec4(color_out, 0.0);"
    ""
    "}";
#elif TEXTURE_INDICES

static const char* vs =
    "#version 330 core\n"
    "layout(location = 0) in vec3 a_Position; "
    "flat out int v_id;"
    "void main() { "
    "   gl_Position = vec4(a_Position, 1.0); "
    "   v_id = gl_VertexID;"
    "}";

const char* gs =
    "#version 330 core\n"
    "uniform mat4 u_ModelMatrix; "
    "uniform mat4 u_ViewMatrix; "
    "uniform mat4 u_ProjectionMatrix; "
    "uniform vec2 u_ViewportSize = vec2(800,600);"
    "uniform samplerBuffer coordinates;"
    "uniform usamplerBuffer triangles;"
    "layout (points) in;"
    ""
    "noperspective out vec3 v_Position;"
    "noperspective out vec3 altitude;"
    "out vec3 v_Normal;"
    "noperspective out vec2 v_Barycentric;"
    ""
    "flat in int v_id[];"
    "layout (triangle_strip , max_vertices = 3) out;"
    ""
    "void main() {"
    "  uint i0 = texelFetch(triangles, 3 * v_id[0]).r;"
    "  uint i1 = texelFetch(triangles, 3 * v_id[0] + 1).r;"
    "  uint i2 = texelFetch(triangles, 3 * v_id[0] + 2).r;"
    ""
    "  vec3 x0 = texelFetch(coordinates, int(i0)).xyz;"
    "  vec3 x1 = texelFetch(coordinates, int(i1)).xyz;"
    "  vec3 x2 = texelFetch(coordinates, int(i2)).xyz;"
    ""
    "  vec4 u = vec4(x1 - x0, 0.0);"
    "  vec4 v = vec4(x2 - x0, 0.0);"
    "  vec3 n = normalize(mat3(transpose(inverse(u_ViewMatrix * "
    "u_ModelMatrix))) * "
    "cross(u.xyz, v.xyz));"
    "  mat4 mv = u_ViewMatrix * u_ModelMatrix;"
    "  mat4 mvp = u_ProjectionMatrix * mv;"
    "  vec4 p0 = mvp * vec4(x0, 1.0);"
    "  vec4 p1 = mvp * vec4(x1, 1.0);"
    "  vec4 p2 = mvp * vec4(x2, 1.0);"
    ""
    "  vec2 q0 = p0.xy / p0.w;"
    "  vec2 q1 = p1.xy / p1.w;"
    "  vec2 q2 = p2.xy / p2.w;"
    ""
    "  vec2 v1 = u_ViewportSize * (q1 - q0);"
    "  vec2 v2 = u_ViewportSize * (q2 - q0);"
    "  vec2 v3 = u_ViewportSize * (q2 - q1);"
    ""
    "  float area = abs(v1.x * v2.y - v1.y * v2.x);"
    "  float h1 = area / length(v3);"
    "  float h2 = area / length(v2);"
    "  float h3 = area / length(v1);"
    ""
    "  gl_Position = p0;"
    "  v_Position  = (mv * vec4(x0, 1.0)).xyz;"
    "  altitude    = vec3(h1, 0, 0);"
    "  v_Normal = n;"
    "  v_Barycentric = vec2(0,0);"
    "  EmitVertex();"
    ""
    "  gl_Position = p1;"
    "  v_Position  = (mv * vec4(x1, 1.0)).xyz;"
    "  altitude    = vec3(0, h2, 0);"
    "  v_Normal = n;"
    "  v_Barycentric = vec2(1,0);"
    "  EmitVertex();"
    ""
    "  gl_Position = p2;"
    "  v_Position  = (mv * vec4(x2, 1.0)).xyz;"
    "  altitude    = vec3(0, 0, h3);"
    "  v_Normal = n;"
    "  v_Barycentric = vec2(0,1);"
    ""
    "  gl_PrimitiveID = gl_PrimitiveIDIn;"
    ""
    "  EmitVertex();"
    "  EndPrimitive();"
    "}";

const char* fs =
    "#version 330 core\n"
    "out vec4 fragColor;"
    "uniform int u_edges;"
    "uniform int u_lighting = 1;"
    ""
    "noperspective in vec3 altitude;"
    "in vec3 v_Normal;"
    "noperspective in vec2 v_Barycentric;"
    "noperspective in vec3 v_Position;"
    ""
    "void "
    "shading(in vec3 l , in vec3 n , in vec3 color , out vec3 color_out) {"
    "  float diffuse = max(0.0,abs(dot(l,n)));"
    "  float phong = 128.0;"
    "  float specular = pow(max(0.0, dot(-reflect(l, n), n)), phong);"
    ""
    "  vec3 cd = color * diffuse;"
    "  vec3 cs = vec3(0.1) * specular;"
    "  vec3 ca = vec3(0.2);"
    "  color_out = ca + cd + cs;"
    "}"

    "void main() {"
    "  float d = min(min(altitude[0], altitude[1]), altitude[2]);"
    "  float I = exp2(-0.5 * d * d);"
    ""
    "  vec3 position = normalize(v_Position);"
    "  vec3 normal = normalize(v_Normal);"
    ""
    "  vec3 color = vec3(0.8, 0.8, 0.8);"
    ""
    "  vec3 color_shaded;"
    "  shading(-position, normal, color, color_shaded);"
    ""
    "  vec3 color_out = color * (1 - u_lighting) + u_lighting * color_shaded;"
    ""
    " fragColor = I * vec4(0, 0, 0, 1.0) + (1.0 - I) * vec4(color_out, 0.0);"
    ""
    "}";

#else
static const char* vs =
    "#version 330 core\n"
    "uniform mat4 u_ModelMatrix; "
    "uniform mat4 u_ViewMatrix; "
    "uniform mat4 u_ProjectionMatrix; "
    "layout(location = 0) in vec3 a_Position; "
    "void main() { "
    "   gl_Position = u_ProjectionMatrix * u_ViewMatrix * u_ModelMatrix "
    "* vec4(a_Position, 1.0); "
    "}";

const char* fs =
    "#version 330 core\n"
    "out vec4 fragColor; "
    "uniform int u_edges;"
    "void main() { "
    "  if (u_edges > 0) fragColor = vec4(0, 0, 0, 0);"
    "  else fragColor = vec4(.8, .8, .8, 0.0); "
    "}";
#endif